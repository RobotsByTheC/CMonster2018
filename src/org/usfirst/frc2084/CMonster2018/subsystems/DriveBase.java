// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2084.CMonster2018.subsystems;

import org.usfirst.frc2084.CMonster2018.Robot;
import org.usfirst.frc2084.CMonster2018.RobotMap;
import org.usfirst.frc2084.CMonster2018.Drive.ArcadeDrive;
import org.usfirst.frc2084.CMonster2018.Drive.JoystickSensitivity;
import org.usfirst.frc2084.CMonster2018.PID.DistancePID;
import org.usfirst.frc2084.CMonster2018.PID.ElevatorPID;
import org.usfirst.frc2084.CMonster2018.PID.HeadingPID;
import org.usfirst.frc2084.CMonster2018.commands.*;

import com.ctre.CANTalon;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.command.Subsystem;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.smartdashboard.*;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class DriveBase extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS


	 
	private final WPI_TalonSRX rightTalon1 = RobotMap.driveBaseRightTalon1;
	private final WPI_TalonSRX leftTalon1 = RobotMap.driveBaseLeftTalon1;
	private final WPI_VictorSPX rightVictor1 = RobotMap.driveBaseRightVictor1;
	private final WPI_VictorSPX leftVictor1 = RobotMap.driveBaseLeftVictor1;
	// the drive motor controllers 
	
	private final WPI_TalonSRX elevatorTalon = RobotMap.elevatorTalon;
	private final WPI_TalonSRX intakeTalon = RobotMap.intakeTalon;
	
	
	private final DoubleSolenoid shiftingGearboxSolenoid = RobotMap.shiftingGearboxSolenoid;
	
	private final AHRS ahrs = RobotMap.ahrs; //navX gyro
	
	public static double leftMotorSpeed;
	public static double rightMotorSpeed;
	public static double miniJoystickOutput;
	double moveSpeed;
	double rotateSpeed;
	public static double LeftDistance;
	public static double RightDistance;
	public static double intakeRotations;
	ArcadeDrive arcadeDrive = new ArcadeDrive();
	private final double WheelDiameter = RobotMap.DRIVE_SUBSYSTEM_WHEEL_DIAMETER;
	JoystickSensitivity joystickSensitivity = new JoystickSensitivity();
	Joystick RightJoystick;
	Joystick LeftJoystick;
	Joystick logitech;
	double[] returnData = new double[2];
	public static boolean shifted = false;
	int gearCheck = 0;
	double nativeUnits = 0;
	boolean autoCheck = false;

	
	
	HeadingPID headingPID = RobotMap.headingPID;
	DistancePID distancePID = RobotMap.distancePID;

	
	public void EnableDriveBase() {
		//don't have to reset anymore because setting to zero does that already
		//don't have to enable anymore because the default of the talons is enabled
	
		rightTalon1.setSelectedSensorPosition(0, 0, 0);
		leftTalon1.setSelectedSensorPosition(0, 0, 0);
		//rightTalon1.set(0);
		//leftTalon1.set(0);
		//elevatorTalon.set(0);
		intakeTalon.set(0);
		//set other talons to zero as well?
		headingPID.enable(); //have to enable PIDs!!!
		distancePID.enable();
		LeftDistance = 0;
		RightDistance = 0;
		RobotMap.AverageDistance = 0;
		
		//elevatorPID.enable();
		Robot.intakeBase.CompressorOn();
		
//		rightTalon1.setSelectedSensorPosition(0, 0, 0);
//		leftTalon1.setSelectedSensorPosition(0, 0, 0);
		
		//intakeTalon.setSelectedSensorPosition(0, 0, 0);
		
	}
	
	public void DisableDriveBase() {
		rightTalon1.disable();
		leftTalon1.disable();
		rightVictor1.disable();
		leftVictor1.disable();
		elevatorTalon.disable();
		intakeTalon.disable();
		distancePID.disable();
		//headingPID.disable();
		//elevatorPID.disable();
		
	}
	
	public void shiftGearboxForward() {
		shiftingGearboxSolenoid.set(DoubleSolenoid.Value.kForward);
		//gearCheck = 0;
		
	}
	
	public void shiftGearboxBackward() {
		shiftingGearboxSolenoid.set(DoubleSolenoid.Value.kReverse);
		//gearCheck = 1;
	}
	
	public void DriveAutonomous() {
		
		
		autoCheck = true;
		SmartDashboard.putBoolean("DidDriveAutonomousRun?", autoCheck);
		
		
		moveSpeed = distancePID.getOutput(); 
		rotateSpeed = headingPID.getOutput();
		
		returnData = arcadeDrive.calculateSpeed(moveSpeed, rotateSpeed);
		leftMotorSpeed = returnData[0];
		rightMotorSpeed = returnData[1];
		
		
		SmartDashboard.putNumber("MoveSpeed", moveSpeed);
		SmartDashboard.putNumber("RotateSpeed", rotateSpeed);
		
		
		//for forced middle program at week 0:
		//leftTalon1.set(-0.25);
		//rightTalon1.set(0.25);
		
		
		leftTalon1.set(-leftMotorSpeed); 
		rightTalon1.set(-rightMotorSpeed); 
		rightVictor1.follow(rightTalon1);
    	leftVictor1.follow(leftTalon1);
		
    	
    	
		LeftDistance = (leftTalon1.getSelectedSensorPosition(0)/26353) * RobotMap.DISTANCE_PER_ROTATION;
		RightDistance = (rightTalon1.getSelectedSensorPosition(0)/26617) * RobotMap.DISTANCE_PER_ROTATION;
		//selectedSensorPosition divided by native units per rotation should yield number of rotations
		
		LeftDistance *= -1;
		
		
		
		RobotMap.AverageDistance = (LeftDistance + RightDistance) / 2;

	
	
	
		SmartDashboard.putNumber("RightTalonSelectedSensorPosition", rightTalon1.getSelectedSensorPosition(0));
		SmartDashboard.putNumber("LeftTalonSelectedSensorPosition", leftTalon1.getSelectedSensorPosition(0));
		SmartDashboard.putNumber("LeftDistance", LeftDistance);
		SmartDashboard.putNumber("RightDistance", RightDistance);
		SmartDashboard.putNumber("LeftMotorSpeed", leftMotorSpeed);
		SmartDashboard.putNumber("RightMotorSpeed", rightMotorSpeed);
		SmartDashboard.putNumber("AverageDistance", RobotMap.AverageDistance);
		SmartDashboard.putNumber("AutonomousYaw", ahrs.getYaw());
		
		

	}
	
	public void JoystickInputs(Joystick RightJoystick, Joystick LeftJoystick, Joystick Logitech) {
		
		
		SmartDashboard.putBoolean("Shifted?", shifted);
		
		
		//teleoperated method 
		leftMotorSpeed = LeftJoystick.getY(); //get value from 1 to -1 from the joysticks, then set it to the talons
		rightMotorSpeed = RightJoystick.getY();
		
		//for control of intake up/down with a mini joystick on the logitech
		//miniJoystickOutput = Logitech.getRawAxis(1);
		//SmartDashboard.putNumber("miniJoystickOutput", miniJoystickOutput);
		//intakeTalon.set(ControlMode.PercentOutput, miniJoystickOutput);
		
		
		//joystick sensitivity inputs replace getY stuff
		leftMotorSpeed = joystickSensitivity.GetOutput(leftMotorSpeed);
		rightMotorSpeed = joystickSensitivity.GetOutput(rightMotorSpeed);
		
		//don't use if/else for now since no pneumatics yet
		/*
		if (gearCheck == 0) {
			nativeUnits = 26353;
		}
		else if (gearCheck == 1) {
			nativeUnits = 12039;
		}
		*/
		
		
		
		
		rightTalon1.set(ControlMode.Velocity, leftMotorSpeed * -12039); //running closed loop, need to multiply by max rpm
		leftTalon1.set(ControlMode.Velocity, rightMotorSpeed * 12039); //max rpm in high gear
		rightVictor1.follow(rightTalon1);
    	leftVictor1.follow(leftTalon1);
    	
    	//elevatorTalon.set(ControlMode.Position, 0);
    	
    	
    	//intake talon
    	//intakeRotations = intakeTalon.getSelectedSensorPosition(0)/4096; //use 4096 to get number of rotations
    	
    	//SmartDashboard.putNumber("IntakeTalonRotations", intakeRotations); //then set to 25 rotations for a 1/4 turn
    	//SmartDashboard.putNumber("IntakeTalonSelectedSensorPosition", intakeTalon.getSelectedSensorPosition(0));
    	
    	
    	
//		LeftDistance = (leftTalon1.getSelectedSensorPosition(0)/26353) * RobotMap.DISTANCE_PER_ROTATION;
//		RightDistance = (rightTalon1.getSelectedSensorPosition(0)/26617) * RobotMap.DISTANCE_PER_ROTATION;
//		RobotMap.AverageDistance = (LeftDistance + RightDistance) / 2;
//		//don't need this in teleop
//    	 
    	
		
		
		
    	//get selected sensor position from elevatorPID, see if has traveled the right amount of 
    	//rotations specified in the command
	
		SmartDashboard.putNumber("LeftSpeed", leftMotorSpeed); //show data on the smart dashboard
		SmartDashboard.putNumber("RightSpeed", rightMotorSpeed);
		SmartDashboard.putNumber("Right Talon Position", rightTalon1.getSelectedSensorPosition(0));
		SmartDashboard.putNumber("Left Talon Position", leftTalon1.getSelectedSensorPosition(0));
		SmartDashboard.putNumber("RightTalonError", rightTalon1.getClosedLoopError(0));
		SmartDashboard.putNumber("LeftTalonError", leftTalon1.getClosedLoopError(0));
		SmartDashboard.putNumber("TeleopYaw", ahrs.getYaw());
	}
	
	
    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    	System.out.println("InitDefaultCommandDriveBaseHasBeenCalled");
    	//each time you deploy this prints out
    	 setDefaultCommand(new DriveWithJoystick());
    	 //each time the robot is enabled the driveWithJoystick is called
    	

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
    	
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

}

