// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2084.CMonster2018.subsystems;

import org.usfirst.frc2084.CMonster2018.Robot;
import org.usfirst.frc2084.CMonster2018.RobotMap;
import org.usfirst.frc2084.CMonster2018.Drive.ArcadeDrive;
import org.usfirst.frc2084.CMonster2018.Drive.JoystickSensitivity;
import org.usfirst.frc2084.CMonster2018.PID.DistancePID;
import org.usfirst.frc2084.CMonster2018.PID.ElevatorPID;
import org.usfirst.frc2084.CMonster2018.PID.HeadingPID;
import org.usfirst.frc2084.CMonster2018.commands.*;

import com.ctre.CANTalon;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.command.Subsystem;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.smartdashboard.*;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class DriveBase extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS


	
	private final WPI_TalonSRX rightTalon1 = RobotMap.driveBaseRightTalon1;
	private final WPI_TalonSRX leftTalon1 = RobotMap.driveBaseLeftTalon1;
	private final WPI_VictorSPX rightVictor1 = RobotMap.driveBaseRightVictor1;
	private final WPI_VictorSPX leftVictor1 = RobotMap.driveBaseLeftVictor1;
	// the drive motor controllers 
	
	
	private final DoubleSolenoid shiftingGearboxSolenoid = RobotMap.shiftingGearboxSolenoid;
	
	private final AHRS ahrs = RobotMap.ahrs; //navX gyro
	
	public static double leftMotorSpeed;
	public static double rightMotorSpeed;
	double moveSpeed;
	double rotateSpeed;
	public static double LeftDistance;
	public static double RightDistance;
	ArcadeDrive arcadeDrive = new ArcadeDrive();
	private final double WheelDiameter = RobotMap.DRIVE_SUBSYSTEM_WHEEL_DIAMETER;
	JoystickSensitivity joystickSensitivity = new JoystickSensitivity();
	Joystick RightJoystick;
	Joystick LeftJoystick;
	double[] returnData = new double[2];
	public static boolean shifted = false;
	int gearCheck = 0;
	double nativeUnits = 0;
<<<<<<< HEAD
	boolean autoCheck = false;
	
=======
>>>>>>> af3868b1acf66bfe1e604fdf4b1ccee0fc457a0e
	
	HeadingPID headingPID = RobotMap.headingPID;
	DistancePID distancePID = RobotMap.distancePID;
	ElevatorPID elevatorPID = RobotMap.elevatorPID;
	
	public void EnableDriveBase() {
		//don't have to reset anymore because setting to zero does that already
		//don't have to enable anymore because the default of the talons is enabled
	
		rightTalon1.set(0);
		leftTalon1.set(0);
		headingPID.enable(); //have to enable PIDs!!!
		distancePID.enable();
		elevatorPID.enable();
		Robot.intakeBase.CompressorOn();
		rightTalon1.setSelectedSensorPosition(0, 0, 0);
		leftTalon1.setSelectedSensorPosition(0, 0, 0);
		//should third argument be nonzero to check for errors?
	}
	
	public void DisableDriveBase() {
		rightTalon1.disable();
		leftTalon1.disable();
		rightVictor1.disable();
		leftVictor1.disable();
		distancePID.disable();
		headingPID.disable();
		elevatorPID.disable();
		
	}
	
	public void shiftGearboxForward() {
		shiftingGearboxSolenoid.set(DoubleSolenoid.Value.kForward);
		//gearCheck = 0;
		
	}
	
	public void shiftGearboxBackward() {
		shiftingGearboxSolenoid.set(DoubleSolenoid.Value.kReverse);
		//gearCheck = 1;
	}
	
	public void DriveAutonomous() {
		
		
		autoCheck = true;
		SmartDashboard.putBoolean("DidDriveAutonomousRun?", autoCheck);
		
		moveSpeed = distancePID.getOutput(); 
		rotateSpeed = headingPID.getOutput();
		
		returnData = arcadeDrive.calculateSpeed(moveSpeed, rotateSpeed);
		leftMotorSpeed = returnData[0];
		rightMotorSpeed = returnData[1];
		
		
<<<<<<< HEAD
		SmartDashboard.putNumber("MoveSpeed", moveSpeed);
		SmartDashboard.putNumber("RotateSpeed", rotateSpeed);
		
=======
		leftTalon1.set(leftMotorSpeed * 12039); //max rpm calculated to be 1287
		rightTalon1.set(rightMotorSpeed * 12039);
		//rightVictor1.follow(rightTalon1);
    	//leftVictor1.follow(leftTalon1);
    
		
		LeftDistance = leftTalon1.getSelectedSensorPosition(0)/4096 * RobotMap.DISTANCE_PER_ROTATION;
		RightDistance = rightTalon1.getSelectedSensorPosition(0)/4096 * RobotMap.DISTANCE_PER_ROTATION;
>>>>>>> af3868b1acf66bfe1e604fdf4b1ccee0fc457a0e
		
		SmartDashboard.putNumber("LeftDistance", LeftDistance);
		SmartDashboard.putNumber("RightDistance", RightDistance);
		SmartDashboard.putNumber("LeftMotorSpeed", leftMotorSpeed);
		SmartDashboard.putNumber("RightMotorSpeed", rightMotorSpeed);
		
		leftTalon1.set(leftMotorSpeed); //max rpm calculated to be 1287
		rightTalon1.set(rightMotorSpeed); //do not make one of these negatives
		//rightVictor1.follow(rightTalon1);
    	//leftVictor1.follow(leftTalon1);
    
		
		LeftDistance = (leftTalon1.getSelectedSensorPosition(0)/26353) * RobotMap.DISTANCE_PER_ROTATION;
		RightDistance = (rightTalon1.getSelectedSensorPosition(0)/26617) * RobotMap.DISTANCE_PER_ROTATION;
		//selectedSensorPosition divided by native units per rotation should yield number of rotations
		
		RightDistance *= -1;
		
		//inverting one of the sides causes a CAN receive timeout
		
		RobotMap.AverageDistance = (LeftDistance + RightDistance) / 2;

	
		SmartDashboard.putNumber("RightTalonSelectedSensorPosition", rightTalon1.getSelectedSensorPosition(0));
		SmartDashboard.putNumber("LeftTalonSelectedSensorPosition", leftTalon1.getSelectedSensorPosition(0));
		SmartDashboard.putNumber("LeftDistance", LeftDistance);
		SmartDashboard.putNumber("RightDistance", RightDistance);
		SmartDashboard.putNumber("LeftMotorSpeed", leftMotorSpeed);
		SmartDashboard.putNumber("RightMotorSpeed", rightMotorSpeed);
		SmartDashboard.putNumber("AverageDistance", RobotMap.AverageDistance);
		SmartDashboard.putNumber("AutonomousYaw", ahrs.getYaw());
		

	}
	
	public void JoystickInputs(Joystick RightJoystick, Joystick LeftJoystick) {
		
		
		SmartDashboard.putBoolean("Shifted?", shifted);
		
		//teleoperated method 
		leftMotorSpeed = LeftJoystick.getY(); //get value from 1 to -1 from the joysticks, then set it to the talons
		rightMotorSpeed = RightJoystick.getY();
		
<<<<<<< HEAD
		//joystick sensitivity inputs replace getY stuff
		leftMotorSpeed = joystickSensitivity.GetOutput(leftMotorSpeed);
		rightMotorSpeed = joystickSensitivity.GetOutput(rightMotorSpeed);
		
=======
>>>>>>> af3868b1acf66bfe1e604fdf4b1ccee0fc457a0e
		//don't use if/else for now since no pneumatics yet
		/*
		if (gearCheck == 0) {
			nativeUnits = 26353;
		}
		else if (gearCheck == 1) {
			nativeUnits = 12039;
		}
		*/
		
<<<<<<< HEAD
		rightTalon1.set(ControlMode.Velocity, leftMotorSpeed * 12039); //running closed loop, need to multiply by max rpm
		leftTalon1.set(ControlMode.Velocity, rightMotorSpeed * -12039); 
		rightVictor1.follow(rightTalon1);
    	leftVictor1.follow(leftTalon1);
    	
    	  //don't need distance calculations here
		LeftDistance = (leftTalon1.getSelectedSensorPosition(0)/4096) * RobotMap.DISTANCE_PER_ROTATION;
		RightDistance = (rightTalon1.getSelectedSensorPosition(0)/4096) * RobotMap.DISTANCE_PER_ROTATION;
		RobotMap.AverageDistance = (LeftDistance + RightDistance) / 2;
=======
		rightTalon1.set(ControlMode.Velocity, rightMotorSpeed * 12039); //running closed loop, need to multiply by max rpm+
		leftTalon1.set(ControlMode.Velocity, leftMotorSpeed * -12039); 
		rightVictor1.follow(rightTalon1);
    	leftVictor1.follow(leftTalon1);
    	
>>>>>>> af3868b1acf66bfe1e604fdf4b1ccee0fc457a0e
		
    	 
    	
    	//get selected sensor position from elevatorPID, see if has traveled the right amount of 
    	//rotations specified in the command
	
		SmartDashboard.putNumber("LeftSpeed", leftMotorSpeed); //show data on the smart dashboard
		SmartDashboard.putNumber("RightSpeed", rightMotorSpeed);
		SmartDashboard.putNumber("Right Talon Position", rightTalon1.getSelectedSensorPosition(0));
		SmartDashboard.putNumber("Left Talon Position", leftTalon1.getSelectedSensorPosition(0));
		SmartDashboard.putNumber("RightTalonError", rightTalon1.getClosedLoopError(0));
		SmartDashboard.putNumber("LeftTalonError", leftTalon1.getClosedLoopError(0));
	}
	
	
    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    	 setDefaultCommand(new DriveWithJoystick());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
    	
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

}

