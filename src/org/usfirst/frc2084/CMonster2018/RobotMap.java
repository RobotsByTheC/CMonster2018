// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2084.CMonster2018;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;

import org.usfirst.frc2084.CMonster2018.PID.DistancePID;
import org.usfirst.frc2084.CMonster2018.PID.ElevatorPID;
import org.usfirst.frc2084.CMonster2018.PID.HeadingPID;

import com.ctre.*;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.Compressor;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.smartdashboard.*;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
	
	public static Compressor robotCompressor;
	public static DoubleSolenoid shiftingGearboxSolenoid;
	public static DoubleSolenoid intakeSolenoid;
	
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
   
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	
	
	public static WPI_TalonSRX driveBaseRightTalon1;
	public static WPI_TalonSRX driveBaseLeftTalon1;
	public static WPI_VictorSPX driveBaseRightVictor1;
	public static WPI_VictorSPX driveBaseLeftVictor1;
	public static WPI_TalonSRX elevatorTalon;
	public static SpeedController climberSpark;
	public static SpeedController rightIntakeSpark;
	public static SpeedController leftIntakeSpark;

	
	
	public static PIDController driveBaseRightPIDController;
	public static PIDController driveBaseLeftPIDController;
	public static Encoder driveBaseLeftEncoder;
	public static Encoder driveBaseRightEncoder;
	
	public static DistancePID distancePID = new DistancePID();
	public static HeadingPID headingPID = new HeadingPID();
	public static ElevatorPID elevatorPID = new ElevatorPID();
	
	public static double AverageDistance;
	public static double talonOutput = 0.5;
	
	public static AHRS ahrs; //the navX
	
	
	public static final double DRIVE_SUBSYSTEM_WHEEL_DIAMETER = 0.3333333;
	public static final double DISTANCE_PER_ROTATION = Math.PI * 0.3333333;
	
	
    public static void init() {
    	
    	
    	robotCompressor = new Compressor(0); //can either use default blank constructor or give it one int parameter
    	shiftingGearboxSolenoid = new DoubleSolenoid(0,0,1);
    	intakeSolenoid = new DoubleSolenoid(0,2,3);
    	
    	

    	driveBaseLeftTalon1 = new WPI_TalonSRX(2);
    	driveBaseRightTalon1 = new WPI_TalonSRX(4);
    	driveBaseLeftVictor1 = new WPI_VictorSPX(3);
    	driveBaseRightVictor1 = new WPI_VictorSPX(5);
    	elevatorTalon = new WPI_TalonSRX(6);
    	
    	
    	climberSpark = new Spark(0); //number is the pwm channels on the roboRIO
    	//button numbers 9 and 1
    	
    	rightIntakeSpark = new Spark(1);
    	//intake fold up and down - button numbers 2 and 4
    	//wheels go/stop - button numbers 5 and 7
    	leftIntakeSpark = new Spark(2);
    	
    	 
 
    	driveBaseRightTalon1.setInverted(false);
    	driveBaseLeftTalon1.setInverted(false);
    	driveBaseRightVictor1.setInverted(false);
    	driveBaseLeftVictor1.setInverted(false);
    	
   
    	/*
    	 * not sure if this stuff is necessary or not 
    	 * 
    	driveBaseLeftTalon1.setNeutralMode(com.ctre.phoenix.motorcontrol.NeutralMode.Brake);
    	driveBaseRightTalon1.setNeutralMode(com.ctre.phoenix.motorcontrol.NeutralMode.Brake);
    	*/
    	
    	//TRANSITION TO CLOSED LOOP
    	//set feedback device
    	driveBaseLeftTalon1.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Absolute, 0, 0);
    	driveBaseRightTalon1.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Absolute, 0, 0);
    	elevatorTalon.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Absolute, 0, 0);
    	
    	//setF term
    	driveBaseLeftTalon1.config_kF(0, 0.146484375, 0);
    	driveBaseRightTalon1.config_kF(0, 0.146484375, 0);
    	driveBaseLeftTalon1.config_kP(0, 0.00787568807, 0);
    	driveBaseRightTalon1.config_kP(0, 0.008254326923, 0);
    	
    	driveBaseRightTalon1.configNeutralDeadband(0.04, 0);
    	driveBaseLeftTalon1.configNeutralDeadband(0.04, 0);
    	//deadband elimination
    	
    	
    	
    	
    	
    	//need to calculate encoder's pulses per revolution
    	//driveBaseLeftEncoder.setDistancePerPulse((1/4096));
    	//driveBaseRightEncoder.setDistancePerPulse(1/4096);
    	
    	//the number 1/4096 represents the number of full rotations 
    	//that the wheel has made in the time of one pulse of the encoder
    	//really small number because pulses are fast
    	//4096 is the number of pulses per revolution (ppr)
    	
    	
    	
    	//set nominal/peak outputs voltage
    			driveBaseLeftTalon1.configNominalOutputForward(0, 0);
    			driveBaseLeftTalon1.configNominalOutputReverse(0, 0);
    			driveBaseRightTalon1.configNominalOutputForward(0,0);
    			driveBaseRightTalon1.configNominalOutputReverse(0, 0);
    			
    			driveBaseLeftTalon1.configPeakOutputForward(1, 0);
    			driveBaseLeftTalon1.configPeakOutputReverse(-1, 0);
    			driveBaseRightTalon1.configPeakOutputForward(1, 0);
    			driveBaseRightTalon1.configPeakOutputReverse(-1, 0);
    			
    			elevatorTalon.configNominalOutputForward(0, 0);
    			elevatorTalon.configNominalOutputReverse(0,0);
    			elevatorTalon.configPeakOutputForward(1, 0);
    			elevatorTalon.configPeakOutputReverse(-1, 0);
    			
    			//setting second argument to zero means no error will be reported if it times out.
    		
    			ahrs = new AHRS(I2C.Port.kMXP, (byte) 100); // the navX!!
    			//needed to import I2C above
    	
    }
    
    
    
}
